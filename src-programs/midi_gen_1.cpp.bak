/* Author:          Ruslan Pantaev <arpiseaQ>
 * License:         GNU Lesser General Public License (LGPL)
 * Start_Date:      6/4/2017
 * Last_modified:   6/11/2017
 */

#include <iostream>
#include <string>
#include <cstdio>               // For std::fopen(), std::fwrite(), std::fclose()
#include <string>
#include <boost/filesystem.hpp> // For creating folders/dir arpiseaQ_6/5/2017_20:51
#include <vector>
#include <unordered_map>        // implementing hashmap for chords arpiseaQ_6/7/2017_10:29

#include "midi_chord_types.h"   // Chord definitions & methods arpiseaQ_6/5/2017_20:43
#include "midi_scale_types.h"   // Scale definitions arpiseaQ_6/6/2017_05:26
#include "midi_gen_bisqwit.h"   // Put midi classes in a sep file arpiseaQ_6/7/2017_13:22
#include "midi_misc.h"          // Not currently in use, but for future implementations

using namespace std;


int main() {
    // unordered_map< string, vector<int> > maptest;
    // maptest["hello"]    = {23,22};
    // maptest["foo"]      = {1,2,3};
    // maptest["maj9"]     = {0,4,7,11,14};

    // if (maptest.find("hello") != maptest.end()) {
    //     cout << "maptest contains key <hello>!" << endl;
    //     unordered_map< string, vector<int> >::iterator it = maptest.find("hello");
    //     cout << "key: " << it->first << " value: ";
    //     for (auto it2 = it->second.begin(); it2 != it->second.end(); ++it2)
    //         cout << *it2 << " ";
    //     cout << endl;
    // }
    // if (maptest.find("foo") != maptest.end()) {
    //     cout << "maptest contains key <foo>! " << endl;
    //     unordered_map< string, vector<int> >::iterator it = maptest.find("foo");
    //     cout << "key: " << it->first << " value: ";
    //     for (auto it2 = it->second.begin(); it2 != it->second.end(); ++it2)
    //         cout << *it2 << " ";
    //     cout << endl;
    // }

    MIDI_Chord hashmap_test;

    /* Populate chord array of chords to be used */
    // int chords[12][5] = { };
    // hashmap_test.return_chord(note::F, "sus2_add_9", &chords[0][0]);
    // hashmap_test.return_chord(note::C, "sus2_add_9", &chords[1][0]);
    // hashmap_test.return_chord(note::G, "sus2_add_9", &chords[2][0]);
    // hashmap_test.return_chord(note::D, "sus2_add_9", &chords[3][0]);
    // hashmap_test.return_chord(note::A, "sus2_add_9", &chords[4][0]);
    // hashmap_test.return_chord(note::E, "sus2_add_9", &chords[5][0]);
    // hashmap_test.return_chord(note::B, "sus2_add_9", &chords[6][0]);
    // hashmap_test.return_chord(note::Gb, "sus2_add_9", &chords[7][0]);
    // hashmap_test.return_chord(note::Db, "sus2_add_9", &chords[8][0]);
    // hashmap_test.return_chord(note::Ab, "sus2_add_9", &chords[9][0]);
    // hashmap_test.return_chord(note::Eb, "sus2_add_9", &chords[10][0]);
    // hashmap_test.return_chord(note::Bb, "sus2_add_9", &chords[11][0]);

    vector<vector<int>> chords_vec;

    //  {
    //     {1,2,3},
    //     {3,4,5},
    //     {2,4,5,6}
    // };

    // vector<int> test1 { 1,2,3 };
    // set_chord(note::Bb, "sus2_add_9");
    // hashmap_test.return_chord(note::Bb, "sus2_add_9", test1);

    chords_vec.push_back(hashmap_test.set_chord(note::Bb, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::F, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::C, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::G, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::D, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::A, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::E, "sus2_add_9"));
    chords_vec.push_back(hashmap_test.set_chord(note::B, "sus2_add_9"));

    // chords_vec.push_back(test1);

    // hashmap_test.return_chord(note::Bb, "sus2_add_9", chords_vec[0]);
    // hashmap_test.return_chord(note::F, "sus4_add_11", chords_vec[1]);
    // hashmap_test.return_chord(note::Bb, "sus4_add_9", chords_vec[2]);
    // hashmap_test.return_chord(note::F, "sus2_add_11", chords_vec[3]);


    // cout << chords_vec[0][0];



    // for (int i=0; i<12; i++)
    //     hashmap_test.chord_octave(&chords[i][0], 1, false);   // false for octave DOWN

    // for (int i=0; i<12; i++)
    //     hashmap_test.chord_octave(&chords[i][0], 2, true);    // true for octave UP

    // for (int i=0; i<12; i++)
    //     hashmap_test.chord_octave(&chords[i][0], 3, true);

    const char x = 128; // Arbitrary value we use here to indicate "no note" 128 for note-off

    MIDI_Scale scl_obj;

    // char chordline[64] = {
    //     0,x,1,2,x,3,x, 4,x,5,x,6,8,x,8,x,  8,x,6,8,x,10,x, 10,x,11,x,6,3,x,5,x,
    //     4,x,3,2,x,1,x, 0,x,5,x,6,8,x,8,x,  6,7,6,x,8,x,9,x,10,9,8,7,6,5,4,3
    // };

    // scl_obj.set_scale(note::D, scl_obj.scl.dorian, 16, &chordline[0]);
    // scl_obj.set_scale(note::D, scl_obj.scl.dorian, 16, &chordline[16]);
    // scl_obj.set_scale(note::A, scl_obj.scl.dorian, 16, &chordline[32]);
    // scl_obj.set_scale(note::D, scl_obj.scl.dorian, 16, &chordline[48]);

    // // cout << "BEFORE: \n";
    // // for (int i=0; i<64; i++) {
    // //     chordline[i] = 'x';
    // // }

    // scl_obj.seed_gen(); // Seeding boost::gen with ctime to generate random numbers every run 

    // scl_obj.rand_rests(chordline, 64);

    // cout << "AFTER: \n";
    // for (int i=0; i<64; i++)
    //     cout << chordline[i] << endl;

    static const char chordline[64] =
    {
        0,1,2,3,4,5,6,7, 1,x,x,x,x,x,x,x,  2,x,x,x,x,x,x,x, 3,x,x,x,x,x,x,x,
        4,x,x,x,x,x,x,x, 5,x,x,x,x,x,x,x,  6,x,x,x,x,x,x,x, 7,x,x,x,x,x,x,x,
    };

    // TODO should these be const static? Maybe it'll be better to be be able to wipe these
    // edit arpiseaQ_6/5/2017_13:21

    static const char chordline2[64] =
    {
        1,x,x,x,x,x,x,x, 2,x,x,x,x,x,x,x,  3,x,x,x,x,x,x,x, 4,x,x,x,x,x,x,x,
        5,x,x,x,x,x,x,x, 6,x,x,x,x,x,x,x,  7,x,x,x,x,x,x,x, 0,x,x,x,x,x,x,x
    };

    // cout << "chordline2: \n";
    // for (int i=0; i<64; i++)
    //     cout << chordline2[i] << endl;

    static const char bassline[64] =
    {   // C=0
        note::C,x,x,x,x,x,x,x, 5,x,x,x,x,x,x,x,  2,x,x,x,x,x,x,x, 1,x,x,x,x,x,x,x,
        5,x,x,x,x,x,x,x, 3,x,x,x,x,x,x,x,  0,x,x,x,x,x,x,x,
        note::C,note::D,note::E,note::F,note::G,note::A,note::B,note::C+note::oct_up
    };
    static const char fluteline[64] =
    {
        x,x,x,x,x,x,x, x,x,x,x,x,x,x,x,x,  x,x,x,x,x,x,x,x, x,x,x,x,x,x,x,x,
        x,x,x,x,x,x,x, x,x,x,x,x,x,x,x,x,  x,x,x,x,x,x,x,x, x,x,x,x,x,x,x,x
    };
    
    MIDIfile file;
    file.set_tempo(1200000);
    file.AddLoopStart();
    
    /* Choose instruments ("patches") for each channel: */
    static const char patches[16] =
    {
        // 0,0,0, 52,52,52, 48,48,48, 0,0,0,0,0, 35,74
        /* 0=piano, 52=choir aahs, 48=strings, 35=fretless bass, 74=pan flute */

        3,3,3, 2,2,2, 30,30,30, 7,7,7,7,7, 35,90
    };

    for (unsigned c=0; c<16; ++c) {
        if (c != 10) // Patch any other channel but not the percussion channel.
            file[0].Patch(c, patches[c]);
    }
    
    int keys_on[16] = {-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1 };

    for (unsigned loops=0; loops<4; ++loops) {          // SET num REPEATS here
        for (unsigned row=0; row<128; ++row) {          // SET length of each measure
            for(unsigned c=0; c<16; ++c) {              // 16 for patches, c stands for CHANNEL
                int note    = x;
                int add     = 0;
                int vol     = 127;

                if (c < 3) { // Piano chord
                    int chord = chordline[row%64];
                    if (chord != x) {
                        note = chords_vec[chord][c%3];
                        add=12*5;
                        vol=0x4B; // equivalent to 75
                    }
                } else if (c >= 3 && c < 5) { // Aux chord (choir)
                    int chord = chordline2[row%64];
                    if (chord != x) {
                        note = chords_vec[chord][c%3];
                        add=12*4;
                        vol=0x50;
                    }
                }
                else if(c >= 6 && c < 8) { // Aux chord (strings)
                    int chord = chordline[row%64];
                    if(chord != x) {
                        note = chords_vec[chord][c%3];
                        add=12*5;
                        vol=0x45;
                    }
                }
                else if (c == 14) { // Bass
                    note = bassline[row%64];
                    add=12*3;
                    vol=122;
                }
                else if (c == 15 && row >= 64) { // Flute
                    note = fluteline[row%64];
                    add=12*5;
                    vol=0x6F;
                }
                if (note == x && (c<15 || row%31)) continue;
                file[0].KeyOff(c, keys_on[c], 0x20);
                keys_on[c] = -1;
                if (note == x) continue;
                file[0].KeyOn(c, keys_on[c] = note+add, vol);   // channel, note number, pressure
            }
            file[0].AddDelay(500);      // val 500 fixes tempo to be playable/locked in at 120bpm
        }
        if(loops == 0) file.AddLoopEnd();
    }
    
    file.Finish();

    if (!boost::filesystem::exists("../midi_files")) {
        boost::filesystem::create_directories("../midi_files");
    }
    int file_num = 0;
    string filename = ("untitled_" + to_string(file_num) + ".mid").c_str();
    while (boost::filesystem::exists( ("../midi_files/"+filename).c_str()) ) {
        file_num++;
        filename = ("untitled_" + to_string(file_num) + ".mid").c_str();
    }

    FILE* outfile = fopen( ("../midi_files/"+filename).c_str(), "wb");
    fwrite(&file.at(0), 1, file.size(), outfile);
    fclose(outfile); 

    cout << "untitled.mid file created successfully \n";
    return 0;
}